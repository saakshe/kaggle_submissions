# -*- coding: utf-8 -*-
"""gemstone_price_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1097NYo8ImT4Ud7t1jouIgE9Wya5o5Amb

importing
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

dataset = pd.read_csv('train.csv')
test = pd.read_csv('test.csv')

"""exploratory data analysis"""

# dataset.head()

# dataset.info()

# dataset.shape

# dataset.describe()

# dataset.isnull().sum()

# sns.histplot(x='clarity', data=dataset )
# plt.show()

# sns.histplot(x='cut', data=dataset )
# plt.show()

# sns.histplot(x='color', data=dataset )
# plt.show()

"""taking care of missing data
~ just dropping the missing data row because it is just single row with missing content 
"""

dataset = dataset.dropna()

# dataset.isnull().sum()

# dataset.shape

"""independent and dependent variables """

X = dataset.iloc[:, 1:-1].values
y = dataset.iloc[:, -1].values
X_test = test.iloc[:, 1:].values

X_test.shape[1]

X.shape[1]

"""encoding categorical data """

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [1, 2, 3])], remainder='passthrough')
X = np.array(ct.fit_transform(X))
X_test = np.array(ct.fit_transform(X_test))

X.shape[1]

X_test.shape[1]

print(X)

"""feature scaling"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X[:, 4:] = sc.fit_transform(X[:, 4:])
X[:, 0:1] = sc.fit_transform(X[:, 0:1])
X_test[:, 4:] = sc.fit_transform(X_test[:, 4:])
X_test[:, 0:1] = sc.fit_transform(X_test[:, 0:1])

"""regression"""

from sklearn.ensemble import RandomForestRegressor
regressor = RandomForestRegressor(n_estimators = 10, random_state = 0)
regressor.fit(X, y)

y_pred = regressor.predict(X_test)
# np.set_printoptions(precision=2)
# y_pred = np.concatenate((y_pred.reshape(len(y_pred),1), y.reshape(len(y_test),1)),1)
print(y_pred)

from google.colab import files
df = pd.DataFrame(data = y_pred)
df.to_csv('output.csv', encoding = 'utf-8-sig') 
files.download('output.csv')